\documentclass[12pt]{article}
\usepackage[letterpaper, margin=1in]{geometry}
\usepackage{mlmodern}
\usepackage{amsthm}
\usepackage{amssymb}

\newenvironment*{solution}{\begin{proof}[Solution]}{\end{proof}}
\renewcommand*{\qedsymbol}{\(\blacksquare\)}

\title{MTH 4320 Homework 8}
\author{Yaohui Wu}
\date{April 10, 2024}

\begin{document}
\maketitle
\section*{Problem 1}
\begin{solution}
    We can use a min-heap and a global counter starting at zero for the key.
    When we push we increment the counter by one then assign it to be the key
    of the element and insert it into the heap. When we pop we decrement the
    counter by one then we remove the last node which is the top of the stack.
    The heap will always be in order since we maintain a counter for the keys.
    Therefore, the time complexity of push and pop is \(O(1)\).
\end{solution}
\section*{Problem 2}
\begin{solution}
    We can start at the parent of the last leaf in the max-heap. For every
    parent in the level we run a modified heapify for a min-heap so we swap
    the parent with the smallest children. We repeat this algorithm until we
    reach the root. Since the max-heap is ordered from greatest to least so
    after we run the algorithm then every parent of the new min-heap will be
    smaller than or equal to its children. The running time of building a heap
    is \(O(n)\). There is no asymptotically faster algorithm because we have
    to visit all \(n\) nodes of the heap. Therefore, the time complexity of
    the algorithm is \(O(n)\).
\end{solution}
\section*{Problem 3}
\begin{solution}
    Let \(M\) be the median and \(X\) be the element we insert or remove.
    \begin{itemize}
        \item Insert: If \(X\) is smaller than the root of the max-heap, then
        we insert it to the max-heap, else we insert it to the min-heap. The
        time complexity is \(O(\log n)\).
        \item Remove: Search \(X\) in the two heaps and remove it. The time
        complexity is \(O(\log n)\).
        \item Find median: If the number of elements is even, then \(M\) is
        the root of the max-heap, else \(M\) is the root of the heap with one
        more element. The time complexity is \(O(1)\).
    \end{itemize}
    If one heap has two more elements than the other, then we remove the root
    of that heap and insert it to the other heap. After we insert or remove,
    run heapify to fix and rebalance the two heaps. Therefore, the root of the
    max-heap is the maximum of the lower half of the elements and the root of
    the min-heap is the minimum of the upper half of the elements so we can
    return the median in \(O(1)\) time.
\end{solution}
\end{document}